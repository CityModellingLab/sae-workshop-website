---
title: "Practical"
format: html
---

## Practical in R: Small Area Estimation

### Introduction

Now that we have learned the fundamentals of small area estimation (SAE), we will apply these concepts to a real dataset. This practical uses a synthetic population for the North East of England, generated by [@castro2024matsim]. The dataset includes \~1 million individuals in the Tyne and Wear region with demographic and mobility-related attributes. Our goal is to estimate the **median income of MSOAs** in Tyne and Wear using SAE methods.

#### Objectives

1.  Evaluate the need for SAE through exploratory data analysis.
2.  Implement different SAE methodologies on synthetic data.
3.  Compare the performance of different methods.

------------------------------------------------------------------------

## Set-up

Load the necessary R libraries:

```{r, message=FALSE, }
library(emdi)
library(survey)
library(SUMMER)
library(sf)
library(dplyr)
library(sfarrow)
library(ggplot2)
library(ggspatial)
library(cowplot)
library(gridExtra)
library(reshape2)
library(spdep)
library(tidyverse)
library(viridis)
library(fastDummies)
```

------------------------------------------------------------------------

## Understanding the Data

We use a **synthetic population** for the Tyne and Wear region. This dataset mimics real-world data while avoiding privacy concerns. Typically, full population data is unavailable, requiring us to work with **sample surveys** instead.

For this workshop, we consider the synthetic population as the **ground truth**. Our samples are **stratified random samples** representing subsets of the full population.

```{r}
# Load sampled data
sample_1pct <- read.csv("./_data/sample_1pct.csv") # 1% sample
sample_5pct <- read.csv("./_data/sample_5pct.csv") # 5% sample
sample_10pct <- read.csv("./_data/sample_10pct.csv") # 10% sample

# Load full synthetic population
SynthPop_NE_2019 <- read.csv("./_data/SynthPop_NE_2019.csv")

# Load MSOA-level population data
pop <- st_read_parquet("./_data/pop_msoa.parquet")
pop <- st_drop_geometry(pop)

# Preview sample data
head(sample_1pct)
```

------------------------------------------------------------------------

### Data Coverage and Exploratory Analysis

Survey samples contain only a fraction of the population, which can lead to regions with **low or missing observations**, making estimates unreliable. Letâ€™s analyze our sample distribution across MSOAs:

```{r, echo=FALSE}
# Load spatial data
msoa_geo <- st_read_parquet("./_data/msoa_geo.parquet")

# Merge sample with MSOA geometries
sample_1pct_geo <- merge(msoa_geo["MSOA11CD"], sample_1pct, by.x = "MSOA11CD", by.y = "Area_MSOA")

# Count observations per MSOA
counts_msoa <- sample_1pct_geo %>% 
  group_by(MSOA11CD) %>% 
  summarise(count = n())

# Visualizing sample coverage
sample_counts <- ggplot() +
  geom_sf(data = counts_msoa, aes(fill = count, colour = count)) +
  scale_fill_distiller(palette = "BuPu", name = "Sample Count") +
  scale_colour_distiller(palette = "BuPu", name = "Sample Count") +
  theme_void() +
  labs(title = "Sample Counts per MSOA (1%)")

# Visualizing total population
pop_totals <- SynthPop_NE_2019 %>% 
  group_by(Area_MSOA) %>% 
  summarise(population = n())

pop_totals_geo <- merge(msoa_geo["MSOA11CD"], pop_totals, by.x = "MSOA11CD", by.y = "Area_MSOA")

total_pop <- ggplot() +
  geom_sf(data = pop_totals_geo, aes(fill = population, colour = population)) +
  scale_fill_distiller(palette = "BuPu", name = "Population") +
  scale_colour_distiller(palette = "BuPu", name = "Population") +
  theme_void() +
  labs(title = "Total Population per MSOA")

# Compare sample coverage with true population
grid.arrange(sample_counts, total_pop, ncol = 2)
```

We see that some MSOAs have **very few observations**, making direct estimates unreliable.

------------------------------------------------------------------------

## Direct Estimator

To generate a direct estimator for `Income` we will apply the Horovitz-Thompson estimator, which

If we do not add sample weights to the estimator, we obtain a naive direct estimator.

```{r}
# Naive direct estimator -- Without considering survey weigths
naive <- sae::direct(y = sample_1pct$Income,
                     dom = sample_1pct$Area_MSOA,
                     domsize = pop)
```

We can also consider survey weights to generate a weighted direct estimator.

```{r}
# Weighted direct estimator -- Adding survey weigths
weighted <- sae::direct(y = sample_1pct$Income,
                     dom = sample_1pct$Area_MSOA, 
                     sweight = sample_1pct$weight, # We add weights
                     domsize = pop)
```

```{r, echo=FALSE}
# Compare results to real data
## Sample data
benchmark_sample <- sample_1pct %>% 
  group_by(Area_MSOA) %>% 
  summarise(median = median(Income)) %>% 
  mutate(source = "sample")

## Population data
benchmark_population <- SynthPop_NE_2019 %>% 
  group_by(Area_MSOA) %>% 
  summarise(median = median(Income)) %>% 
  mutate(source = "population")

## Naive estimator
naive <- naive %>% 
  dplyr::select(Domain, Direct) %>% 
  rename(Area_MSOA = Domain,
         median = Direct) %>% 
  mutate(source = "naive")

## Weighted
weighted <- weighted %>% 
  dplyr::select(Domain, Direct) %>% 
    rename(Area_MSOA = Domain, 
           median = Direct) %>% 
  mutate(source = "weighted")

## Bring all data together
df_list <- list(naive, weighted, benchmark_sample, benchmark_population)
df <- bind_rows(df_list)

# Plot
p <- ggplot() +
  geom_density(data = df, aes(x = median, fill = source), alpha = .7) +
  scale_fill_manual(values = c("#e07a5f","#3d405b","#81b29a","#f2cc8f")) +
  theme_minimal()
ggsave(plot = p, filename = "./_figures/direct_density.png")

```

```{r, echo=FALSE}
# Map outputs
gdf <- merge(df, msoa_geo, by.x = "Area_MSOA", by.y = "MSOA11CD") %>% st_as_sf()
p <- ggplot() +
  geom_sf(data = gdf, aes(fill = median, colour = median)) +
  scale_fill_viridis_c(option = "inferno", name = "Median Income", direction = 1) +
  scale_colour_viridis_c(option = "inferno", name = "Median Income", direction = 1) +
  facet_wrap(~source, nrow = 1) +
  theme_map()

ggsave(plot = p, filename = "./_figures/direct_maps.png")
p
```

------------------------------------------------------------------------

## Smoothed Estimators

Smoothed estimators **borrow information** from other areas to improve estimates for low-sample regions.

```{r}
# Prepare population data
sample_1pct$pop <- sum(pop$population[match(sample_1pct$Area_MSOA, pop$MSOA11CD)])

# Survey design
design <- survey::svydesign(ids = ~1,
                            weights = ~weight,
                            data = sample_1pct,
                            fpc = ~pop)

# Direct estimator using `SUMMER`
smooth <- smoothArea(formula = Income~1,
                 domain = ~Area_MSOA,
                 design = design,
                 domain.size = pop %>% st_drop_geometry(),
                 return.samples = T)

# Make table
df <- data.frame(Area_MSOA = smooth$direct.est$domain,
           direct = smooth$direct.est$median,
           smoothed = smooth$iid.model.est$mean,
           se_direct = sqrt(smooth$direct.est$var),
           se_smoothed = sqrt(smooth$iid.model.est$var)) %>% 
  pivot_longer(cols = c(direct, smoothed, se_direct, se_smoothed), 
               names_to = "estimate_type", 
               values_to = "estimate_value")


# Add coordinates for mapping
df <- merge(df, msoa_geo, by.x = "Area_MSOA", by.y = "MSOA11CD") %>%
  st_as_sf()

# Map
m <- ggplot() +
  geom_sf(data = df, aes(fill = estimate_value, colour = estimate_value)) +
  scale_fill_viridis_c(option = "magma", name = "GBP", direction = 1) +
  scale_colour_viridis_c(option = "magma", name = "GBP", direction = 1) +
  facet_wrap(~estimate_type, nrow = 1) +
  theme_map()

ggsave(plot = m, filename = "./_figures/smooth_maps.png")
m
```

------------------------------------------------------------------------

## Area-Based Estimators

We incorporate **spatial dependencies** into the model using an adjacency matrix.

```{r}
# We want to incorporate a spatial element into our model
# We need to know which regions are close to each other
# Therefore, we generate an adjacency matrix
mat <- nb2mat(poly2nb(msoa_geo), style = "B")

# Set column and row names to adjacency matrix
colnames(mat) <- rownames(mat) <- msoa_geo$MSOA11CD

# Make sure there is no mismatch between the areas in the adjacency matrix and those in the design
common_areas <- intersect(rownames(mat), unique(design$variables$Area_MSOA))
mat <- mat[common_areas,common_areas]

# Direct estimator using `SUMMER`
area_based <- smoothArea(formula = Income~1,
                 domain = ~Area_MSOA,
                 design = design,
                 adj.mat = mat)

```

```{r}
# Add covariates to enrich the model
Xmat <- aggregate(Age~Area_MSOA, data = sample_1pct, FUN = mean)

# Estimate model with covariates
area_based_covar <- smoothArea(Income ~ Age,
                       domain = ~Area_MSOA,
                       design = design,
                       adj.mat = mat,
                       X.domain = Xmat)


```

```{r}
length(unique(sample_1pct$Area_MSOA))
length(unique(SynthPop_NE_2019$Area_MSOA))

nrow(area_based_covar$direct.est)
ncol(mat)
```

```{r}
# Convert covariates to dummies
census_covars <- dummy_cols(SynthPop_NE_2019, select_columns = c('Sex', 'Ethnic', 'Marital_status','Children_dependency','Economic_activity','Economic_activity'), remove_first_dummy = T, remove_selected_columns = T)

# Create covariates to enrich the model
X_mat <- aggregate(cbind(Age, Sex_2, Ethnic_4, Ethnic_6, Ethnic_8, Marital_status_Single,Children_dependency_TRUE) ~ Area_MSOA, data = census_covars, FUN = mean)

# Estimate model with covariates
# area_based_covar <- smoothArea(Income ~ Age + Sex_2,
#                        domain = ~Area_MSOA,
#                        design = design,
#                        adj.mat = mat,
#                        X.domain = X_mat)
```

```{r}
# Prepare comparison plots
## Direct estimator -- Area-based with covariates
direct_area_based_covar <- area_based_covar$direct.est %>% 
  dplyr::select(domain, median) %>% 
  rename(Area_MSOA = domain) %>% 
  mutate(source = "direct")

## IID model -- Area-based with covariates
iid_area_based_covar <- area_based_covar$iid.model.est %>% 
  dplyr::select(domain, median) %>% 
  rename(Area_MSOA = domain) %>% 
  mutate(source = "iid")

## BYM2 model -- Area-based with covariates
bym2_area_based_covar <- area_based_covar$bym2.model.est %>% 
  dplyr::select(domain, median) %>% 
  rename(Area_MSOA = domain) %>% 
  mutate(source = "bym2")

## Bind rows
combined_estimates <- bind_rows(direct_area_based_covar, bym2_area_based_covar, iid_area_based_covar)

## Filter populations values that are not in estimates
filtered_benchmark_population <- benchmark_population %>% filter(Area_MSOA %in% direct_area_based_covar$Area_MSOA)

## Merge everything together
plot_data <- combined_estimates %>%
  left_join(benchmark_population %>% select(Area_MSOA, median), by = "Area_MSOA") %>%
  rename(benchmark_median = median.y, estimate_median = median.x)

# Scatter plot
ggplot(plot_data, aes(x = benchmark_median, y = estimate_median, color = source)) +
  geom_point(alpha = 0.7) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "black") +  # 45-degree reference line
  labs(
    x = "Benchmark Population Median",
    y = "Model Estimates Median",
    color = "Source",
    title = "Comparison of Model Estimates vs Benchmark Population"
  ) +
  theme_minimal()
```

```{r}
# Density functions
combined_estimates <- bind_rows(direct_area_based_covar, 
                                bym2_area_based_covar, 
                                iid_area_based_covar, 
                                benchmark_population)

p <- ggplot() +
  geom_density(data = combined_estimates, aes(x = median, fill = source), alpha = .7) +
  scale_fill_manual(values = c("#e07a5f","#3d405b","#81b29a","#f2cc8f")) +
  theme_minimal()
ggsave(plot = p, filename = "./_figures/area-level-density.png")
p
```

```{r}
gdf <- merge(combined_estimates, 
             msoa_geo, 
             by.x = "Area_MSOA",
             by.y = "MSOA11CD") %>% 
  st_as_sf()

m <- ggplot() +
  geom_sf(data = gdf, aes(fill = median, colour = median)) +
  scale_fill_viridis_c(option = "magma", name = "GBP", direction = 1) +
  scale_colour_viridis_c(option = "magma", name = "GBP", direction = 1) +
  facet_wrap(~source, nrow = 1) +
  theme_map()
ggsave(plot = m, filename = "./_figures/area-level-maps.png")
m
```
# Predict missing values

```{r}
# Step 1: Merge demographic covariates with area-level estimates
full_df <- left_join(X_mat, bym2_area_based_covar, by = "Area_MSOA")

# Step 2: Fit linear model to non-missing median values
model <- lm(
  median ~ Age + Sex_2 + Marital_status_Single + Children_dependency_TRUE,
  data = full_df
)

summary(model)

# Step 3: Predict values where median is missing
full_df <- full_df %>%
  mutate(
    prediction = ifelse(is.na(median),
                        predict(model, newdata = .),
                        NA),
    median = ifelse(is.na(median), prediction, median),
    source = ifelse(is.na(source) & !is.na(prediction), "prediction", source)
  )

# Optional: Assess predictions vs. benchmark
groundtruth <- left_join(
  full_df %>% filter(source == "prediction"),
  benchmark_population,
  by = "Area_MSOA"
)

ggplot(data = groundtruth) +
  geom_point(aes(x = prediction, y = median.y)) +
  geom_abline(intercept = 0, slope = 1) +
  scale_x_continuous(expand = c(0, 0), limits = c(0, 35000)) +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 35000)) +
  coord_fixed()  # optional: keeps the aspect ratio square

# Step 4: Prepare data for mapping
map_df <- left_join(
  full_df %>% select(Area_MSOA, median),
  msoa_geo,
  by = c("Area_MSOA" = "MSOA11CD")
) %>% st_as_sf()

ggplot() +
  geom_sf(data = map_df, aes(fill = median, colour = median)) +
  scale_fill_viridis_c(option = "magma", name = "GBP", direction = 1) +
  scale_colour_viridis_c(option = "magma", name = "GBP", direction = 1) +
  theme_void()

```









