<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Introduction to SAE – SAE Workshop</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-6bd9cfa162949bde0a231f530c97869d.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./introduction.html">Introduction to SAE</a></li><li class="breadcrumb-item"><a href="./introduction.html">Introduction to SAE</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">SAE Workshop</a> 
        <div class="sidebar-tools-main">
    <div class="dropdown">
      <a href="" title="" id="quarto-navigation-tool-dropdown-0" class="quarto-navigation-tool dropdown-toggle px-1" data-bs-toggle="dropdown" aria-expanded="false" role="link" aria-label=""><i class="bi bi-github"></i></a>
      <ul class="dropdown-menu" aria-labelledby="quarto-navigation-tool-dropdown-0">
          <li>
            <a class="dropdown-item sidebar-tools-main-item" href="https://github.com/cpeiretgarcia/sae-workshop-website">
            Source Code
            </a>
          </li>
      </ul>
    </div>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Home</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Introduction to SAE</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./introduction.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Introduction to SAE</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#background" id="toc-background" class="nav-link active" data-scroll-target="#background">Background</a>
  <ul class="collapse">
  <li><a href="#introduction-to-small-area-estimation" id="toc-introduction-to-small-area-estimation" class="nav-link" data-scroll-target="#introduction-to-small-area-estimation">Introduction to Small Area Estimation</a></li>
  <li><a href="#challenges-to-traditional-survey-based-estimation" id="toc-challenges-to-traditional-survey-based-estimation" class="nav-link" data-scroll-target="#challenges-to-traditional-survey-based-estimation">Challenges to traditional survey-based estimation</a></li>
  <li><a href="#how-small-area-estimation-helps" id="toc-how-small-area-estimation-helps" class="nav-link" data-scroll-target="#how-small-area-estimation-helps">How small area estimation helps</a></li>
  <li><a href="#real-world-applications-of-sae" id="toc-real-world-applications-of-sae" class="nav-link" data-scroll-target="#real-world-applications-of-sae">Real-world applications of SAE</a></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  <li><a href="#the-concept-and-its-relevance" id="toc-the-concept-and-its-relevance" class="nav-link" data-scroll-target="#the-concept-and-its-relevance">The concept and its relevance</a></li>
  <li><a href="#key-concepts-of-sae" id="toc-key-concepts-of-sae" class="nav-link" data-scroll-target="#key-concepts-of-sae">Key concepts of SAE</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./introduction.html">Introduction to SAE</a></li><li class="breadcrumb-item"><a href="./introduction.html">Introduction to SAE</a></li></ol></nav>
<div class="quarto-title">
<h1 class="title">Introduction to SAE</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="background" class="level1">
<h1>Background</h1>
<p>In recent years, there has been an increasing demand for detailed disaggregated data at small geographical levels. The growing interest in subnational spatial units such as cities, neighbourhoods, and other small areas requires more granular data than what is typically available. This detailed information is essential for making informed policy decisions and effectively monitoring specific goals. For example, fields like poverty mapping, income estimation, health statistics, or environmental monitoring often require reliable estimates of subpopulations or domains where samples are too small or even non-existent <span class="citation" data-cites="molina2010small">[@molina2010small, @rao2016empirical, @clark2021small, @lahiri2006small]</span>. This can cause severe problems when trying to draw conclusions about these small areas.</p>
<p>Traditionally, the way of obtaining information about an area involves the use of sample surveys. Survey sampling consists of selecting an <span class="math inline">\(n\)</span> number of observations from a finite population of <span class="math inline">\(N\)</span> individuals and using the sample to draw conclusions about the entire population <span class="citation" data-cites="chambers2011sample">[@chambers2011sample]</span>. Typically, these surveys allow for generating estimates for the total population and, usually, some specific domains. However, many times analysts need to make estimates for areas that are different from the predefined survey domains. What usually happens is that the sample sizes of these desired areas are either too small or even non-existent, which causes serious problems when trying to draw reliable estimators <span class="citation" data-cites="morales2021course">[@morales2021course]</span>. This is because the small population sizes of these domains derive in unacceptably large standard errors, making the estimators unreliable <span class="citation" data-cites="ghosh1994small">[@ghosh1994small]</span>.</p>
<p>This section will provide the necessary background information to understand what SAE is and why it is necessary for overcoming the limitations associated with traditional sample-based estimations.</p>
<section id="introduction-to-small-area-estimation" class="level2">
<h2 class="anchored" data-anchor-id="introduction-to-small-area-estimation">Introduction to Small Area Estimation</h2>
<p>Small area estimation (SAE) is a statistical technique for producing reliable information for small groups or regions when regular survey data does not provide enough information. This methodology combines existing survey data with auxiliary information –such as census data, or other appropriate indicators– to improve the estimates[^An estimate is an educated guess on the approximate value of a variable based on available data.] for our variable of interest.</p>
<p>Traditionally, one way to generate an estimate is using the sample information to draw conclusions about the whole population. This can be done by simply suming the sample values of the variable of interest –target variable– and multiply it by the sample weights <span class="citation" data-cites="horvitz1952generalization">[@horvitz1952generalization]</span>. Methods that only use smaple data to generate estimates about the target variable are known as <strong>direct estimators</strong>. Direct methods pose a series of advantages, such as their simplicity and intuitive calculation or the lack of dependance on external data sources. However, the very qualities that make these estimators attractive are also their greatest limitations. Since they rely only on sample data, their accuracy is directly linked to the sample’s size and representativeness, a challenge that is not always easy to solve.</p>
<p>To exemplify the problem, let us assume that we are interested in estimating child malnutrition rates in rural areas. Suppose a national health survey is conducted to assess malnutrition, but the sample size varies across districts. In urban centers, where more data is collected, direct estimators can provide reasonably accurate and stable estimates. However, in rural districts with smaller sample sizes, the same method produces highly unstable estimates, making it difficult to determine whether a district truly has higher or lower malnutrition rates or if the observed differences are simply due to random variation. This lack of reliability poses a serious challenge for policymakers and organizations that need precise data to allocate resources effectively. In such cases, alternative methods are needed to improve these estimates, allowing for more robust and stable results even when direct survey data is limited.</p>
</section>
<section id="challenges-to-traditional-survey-based-estimation" class="level2">
<h2 class="anchored" data-anchor-id="challenges-to-traditional-survey-based-estimation">Challenges to traditional survey-based estimation</h2>
<p>The main challenge that justifies the use of small area estimation (SAE) over traditional survey-based methods is the lack of sufficiently large sample sizes. In the previous example, authorities sought to obtain a more detailed understanding of malnutrition rates among children in rural areas. However, for some districts, the available sample sizes were too small to yield reliable estimates, leading to high uncertainty. To illustrate why small samples can be problematic, we can use a simpler example.</p>
<p>Consider the probability of getting heads when tossing a fair coin. We know that, in theory, the probability of heads is <span class="math inline">\(0.5\)</span>. However, if we only toss the coin a few times, the observed proportion of heads can fluctuate significantly, leading to unstable estimates of the true probability. The smaller the number of tosses, the more random variation we see. To demonstrate this effect, we can simulate what happens as we increase the number of tosses (sample size), using <span class="math inline">\(n = (5, 10, 50, 500)\)</span>. By comparing the results, we can see how larger sample sizes reduce variability, producing estimates that are closer to <span class="math inline">\(0.5\)</span>, the true probability—just as SAE helps stabilise estimates when working with small datasets.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="introduction_files/figure-html/unnamed-chunk-1-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Increasing the sample size is, however, not always viable. The two main reasons for this are the monetary cost and the impracticality of increased samples. Every additional survey response requires more resources –interviewer wages, transportation, data processing, administrative overhead– that sometimes are unavailable. These costs can be even higher if the surveys have to be conducted in remote or hard-to-reach areas. Additionally, if we work with past surveys, increasing the sample size is not possible. It could also be the case that some target populations are difficult to access or are reluctant to provide information. In this cases, sample sizes will also be very limited and difficult to expand.</p>
</section>
<section id="how-small-area-estimation-helps" class="level2">
<h2 class="anchored" data-anchor-id="how-small-area-estimation-helps">How small area estimation helps</h2>
<p>SAE methods are designed to improve the efficiency of the estimations derived from direct methods by combining survey sampling methodologies with statistical models. SAE allows for estimating parameters of small subsets –often refered to as small areas or domains– of the original population. These domains can represent either a geographical area or a population subgroup for which the sample is small <span class="citation" data-cites="morales2021course">[@morales2021course]</span>.</p>
<p>Contrary to direct estimation methods, SAE improves the quality of the estimates by using data from outside the domain area. This is achieved by identifying similar domains and leveraging their data to improve the estimate for the area of interest, effectively “borrowing strength” from related regions or subpopulations to improve accuracy. SAE can also incorporate information from different time periods as auxiliary data from either the same or a different domain area.</p>
</section>
<section id="real-world-applications-of-sae" class="level2">
<h2 class="anchored" data-anchor-id="real-world-applications-of-sae">Real-world applications of SAE</h2>
<p>SAE’s versatility as a statistical methodology has led to its application across multiple fields. National institutes of statistics and other international organisations –UK Office for National Statistics, US Bureau of Census, the Statistical Office of Italy, or the United Nations– rely on this methodology to produce estimates for domains not explicitly included in the sampling design <span class="citation" data-cites="kreutzmann2019r">[@kreutzmann2019r]</span>. This information is particularly useful for policy making and resource allocation. For instance, in the UK, the Office for National Statistics’ unemployment annual unemployment estimates and the estimates of average income by electoral ward are calculated following this methodology <span class="citation" data-cites="ONS2020SAE">[@ONS2020SAE]</span>. International organisations such as the World Bank have also applied SAE to estimating poverty rates [@]. With estimates at local level being key for poverty reduction, having information at higher spatial resolution helps policy-makers delivering better targetted policies and resource allocation.</p>
<p><span class="citation" data-cites="finucane2014bayesian">@finucane2014bayesian</span> combined a wide range of data soures to estimate trends on health indicators at country, region, and global levels. The methodology used in this study borrows strength in time, age, covariates, and within and across country clusters to generate unbiased estimators in domains where data are sparse.</p>
<p><span class="citation" data-cites="bennett2023changes">@bennett2023changes</span> explores the relationship between life expectancy changes at very small area level and housing prices and their evolution.</p>
<ul>
<li>Poverty mapping</li>
<li>Education</li>
<li>Environmental monitoring</li>
</ul>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
</section>
<section id="the-concept-and-its-relevance" class="level2">
<h2 class="anchored" data-anchor-id="the-concept-and-its-relevance">The concept and its relevance</h2>
<p>Small area estimation (SAE) is a statistical technique used to generate reliable estimates for geographic or demographic areas (domains) where sample sizes are limited <span class="citation" data-cites="morales2021course">[@morales2021course]</span>. This technique has long been used, particularly by demographers interested in estimating population counts and other variables of interest for small areas <span class="citation" data-cites="rao2015small">[@rao2015small]</span>. Applications of SAE to disease mapping by epidemiologists and demographers have been dated back to the eleventh century in England and seventeenth century in Canada <span class="citation" data-cites="ghosh1994small">[@ghosh1994small]</span>. These primitive small area statistics were primarily based on either census or administrative records, and aimed at complete enumeration, a much more costly approach than nowadays sample survey methods.</p>
<blockquote class="blockquote">
<p>If you are trying to draw a conclusion about a group of people based on your knowledge of just a few of them, chances are you will make a mistake and your conclusions will be wrong. This is what having “unacceptably large standard errors” means.</p>
</blockquote>
<blockquote class="blockquote">
<p><strong>Q1: Why not just increasing the sample size?</strong> This would be an easy solution to this problem. However, in most cases expanding the sample is expensive, or even impossible if the analyst is using secondary data.</p>
</blockquote>
</section>
<section id="key-concepts-of-sae" class="level2">
<h2 class="anchored" data-anchor-id="key-concepts-of-sae">Key concepts of SAE</h2>
<ul>
<li><strong>Small area (or domain)</strong>: is the geographic area or subpopulation where the data is scarce or even non-existent.</li>
<li><strong>Target variable</strong>: is the variable of interest for which estimates are being produced.</li>
<li><strong>Estimator</strong>: is a statistical formula used for calculating an unknown population parameter based on sample data.</li>
</ul>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>